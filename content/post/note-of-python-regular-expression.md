+++
date = "2016-01-10T08:35:29+08:00"
draft = true
title = "note of python regular expression"

+++



如果在’[‘ ‘]’里面的开头写一个 ‘^’ 号，则表示取非，即在括号里的字符都不匹配。如[^a-zA-Z]表明不匹配所有英文字母。但是如果 ‘^’不在开头，则它就不再是表示取非，而表示其本身，如[a-z^A-Z]表明匹配所有的英文字母和字符’^’。

它的有效范围是它两边的整条规则，比如‘dog|cat’匹配的是‘dog’和’cat’，而不是’g’和’c’。如果想限定它的有效范围，必需使用一个无捕获组 ‘(?: )’包起来。比如要匹配 ‘I have a dog’或’I have a cat’，需要写成r’I have a (?:dog|cat)’ ，而不能写成 r’I have a dog|cat’

‘/b’ 匹配单词边界
它匹配一个单词的边界，比如空格等，不过它是一个‘0’长度字符，它匹配完的字符串不会包括那个分界的字符。而如果用’/s’来匹配的话，则匹配出的字符串中会包含那个分界符。

‘\*’ ‘+’ ‘?’通常都是尽可能多的匹配字符。有时候我们希望它尽可能少的匹配。比如一个c语言的注释 ‘/* part 1 */ /\* part 2 \*/’

括号中的’…’代表你希望匹配的字符串后面应该出现的字符串。
例： 你希望找出c语言的注释中的内容，它们是包含在’/*’和’*/’之间，不过你并不希望匹配的结果把’/*’和’*/’也包括进来

‘/number’ 通过序号调用已匹配的组
正则式中的每个组都有一个序号，序号是按组从左到右，从1开始的数字，你可以通过下面的形式来调用已匹配的组

M MULTILINE 多行匹配。在这个模式下’^’(代表字符串开头)和’$’(代表字符串结尾)将能够匹配多行的情况，成为行首和行尾标记

S DOTALL ‘.’号将匹配所有的字符。缺省情况下’.’匹配除换行符’/n’外的所有字符，使用这一选项以后，’.’就能匹配包括’/n’的任何字符了。

X VERBOSE 这个选项忽略规则表达式中的空白，并允许使用’#’来引导一个注释。这样可以让你把规则写得更美观些。

sub返回一个被替换的字符串
subn返回一个元组，第一个元素是被替换的字符串，第二个元素是一个数字，表明产生了多少次替换。

将一个正则式，使用compile函数编译，不仅是为了提高匹配的速度，同时还能使用一些附加的功能。编译后的结果生成一个Pattern对象，这个对象里面有很多函数，他们看起来和re模块的函数非常象，它同样有findall , match , search ,finditer , sub , subn , split 这些函数，只不过它们的参数有些小小的不同。一般说来，re模块函数的第一个参数，即正则规则不再需要了，应为规则就包含在Pattern对象中了，编译选项也不再需要了，因为已经被编译过了。因此re模块中函数的这两个参数的位置，就被后面的参数取代了。

正则式中的每个组都有一个序号，它是按定义时从左到右的顺序从1开始编号的。其实，re的正则式还有一个0号组，它就是整个正则式本身。